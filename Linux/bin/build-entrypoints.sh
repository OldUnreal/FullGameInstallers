#!/usr/bin/env bash
# shellcheck source-path=SCRIPTDIR
# ARGBASH_SET_INDENT([  ])
# ARG_OPTIONAL_BOOLEAN([lint],[l],[Lint generated files with shellcheck],[on])
# ARG_OPTIONAL_BOOLEAN([format],[f],[Format all files with shfmt.],[on])
# ARG_HELP([Generate entrypoints from source files])
# ARG_VERSION_AUTO([1.0],['OldUnreal <https://oldunreal.com>'])
# DEFINE_SCRIPT_DIR([_SCRIPT_DIR])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.11.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info


die()
{
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo "$1" >&2
  exit "${_ret}"
}


begins_with_short_option()
{
  local first_option all_short_options='lfhv'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_lint="on"
_arg_format="on"


print_help()
{
  printf '%s\n' "Generate entrypoints from source files"
  printf 'Usage: %s [-l|--(no-)lint] [-f|--(no-)format] [-h|--help] [-v|--version]\n' "$0"
  printf '\t%s\n' "-l, --lint, --no-lint: Lint generated files with shellcheck (on by default)"
  printf '\t%s\n' "-f, --format, --no-format: Format all files with shfmt. (on by default)"
  printf '\t%s\n' "-h, --help: Prints help"
  printf '\t%s\n' "-v, --version: Prints version"
}


parse_commandline()
{
  local _key
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -l|--no-lint|--lint)
        _arg_lint="on"
        test "${1:0:5}" = "--no-" && _arg_lint="off"
        ;;
      -l*)
        _arg_lint="on"
        _next="${_key##-l}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-l" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -f|--no-format|--format)
        _arg_format="on"
        test "${1:0:5}" = "--no-" && _arg_format="off"
        ;;
      -f*)
        _arg_format="on"
        _next="${_key##-f}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-f" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      -v|--version)
        printf '%s %s\n\n%s\n%s\n' "build-entrypoints.sh" "1.0" 'Generate entrypoints from source files' 'OldUnreal <https://oldunreal.com>'
        exit 0
        ;;
      -v*)
        printf '%s %s\n\n%s\n%s\n' "build-entrypoints.sh" "1.0" 'Generate entrypoints from source files' 'OldUnreal <https://oldunreal.com>'
        exit 0
        ;;
      *)
        _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
        ;;
    esac
    shift
  done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash
_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || { echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2; exit 2; }

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# Enable Bash Strict Mode
set -euo pipefail

if [ "${_arg_lint}" == "on" ] && ! command -v shellcheck &>/dev/null; then
  die "shellcheck must be installed to format the files"
fi

if [ "${_arg_format}" == "on" ] && ! command -v shfmt &>/dev/null; then
  die "shfmt must be installed to format the files"
fi

_SRC_ROOT="$(realpath "${_SCRIPT_DIR}/../src")"

if [ "${_arg_format}" == "on" ]; then
  shfmt --indent 2 --write "${_SRC_ROOT}"
fi

while IFS= read -r -d '' ENTRYPOINT_FILE_PATH; do
  ENTRYPOINT_BASENAME=${ENTRYPOINT_FILE_PATH##*/}
  DESTINATION_FILE="${_SCRIPT_DIR}/../${ENTRYPOINT_BASENAME}"
  DESTINATION_SWAP="${_SCRIPT_DIR}/../${ENTRYPOINT_BASENAME}.swap"

  cp -f "${ENTRYPOINT_FILE_PATH}" "${DESTINATION_FILE}"

  while grep -Eq "^\s*#\s*@include\s+" "${DESTINATION_FILE}"; do
    # Process the file and save to a swap file
    sed -Ee '/^\s*#\s*@include/ {
          s|^\s*#\s*@include\s+(.*)|cat "'"${_SRC_ROOT}"'/\1"|
          e
      }' "${DESTINATION_FILE}" >"${DESTINATION_SWAP}"

    # Move the expanded version back to the temp file for the next pass
    mv -f "${DESTINATION_SWAP}" "${DESTINATION_FILE}"
  done

  if [ "${_arg_format}" == "on" ]; then
    shfmt --indent 2 --write "${DESTINATION_FILE}"
  fi

  if [ "${_arg_lint}" == "on" ]; then
    shellcheck "${DESTINATION_FILE}"
  fi

  chmod +x "${DESTINATION_FILE}"
done < <(find "${_SRC_ROOT}/entrypoints" -maxdepth 1 -name "*.sh" -print0)
# ] <-- needed because of Argbash
