#!/usr/bin/env bash
#
# Unreal Tournament: GOTY Linux Installer
#
# shellcheck source-path=SCRIPTDIR
# ARGBASH_SET_INDENT([  ])
# ARG_OPTIONAL_SINGLE([destination],[d],[Install directory. Will be created if it doesn't exist.],[${XDG_DATA_DIR:-${HOME}/.local/share}/OldUnreal/UnrealTournament])
# ARG_OPTIONAL_SINGLE([ui-mode],[],[UI library to use during install.],[auto])
# ARG_TYPE_GROUP_SET([uimode],[MODE],[ui-mode],[auto,kdialog,zenity,none])
# ARG_OPTIONAL_BOOLEAN([keep-installer-files],[k],[Keep ISO and Patch files.],[])
# ARG_HELP([Install Unreal Tournament: GOTY])
# ARG_VERSION_AUTO([1.0],['OldUnreal <https://oldunreal.com>'])
# DEFINE_SCRIPT_DIR([_SCRIPT_DIR])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.11.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info

die() {
  local _ret="${2:-1}"
  test "${_PRINT_HELP:-no}" = yes && print_help >&2
  echo "$1" >&2
  exit "${_ret}"
}

# validators

uimode() {
  local _allowed=("auto" "kdialog" "zenity" "none") _seeking="$1"
  for element in "${_allowed[@]}"; do
    test "$element" = "$_seeking" && echo "$element" && return 0
  done
  die "Value '$_seeking' (of argument '$2') doesn't match the list of allowed values: 'auto', 'kdialog', 'zenity' and 'none'" 4
}

begins_with_short_option() {
  local first_option all_short_options='dkhv'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_destination="${XDG_DATA_DIR:-${HOME}/.local/share}/OldUnreal/UnrealTournament"
_arg_ui_mode="auto"
_arg_keep_installer_files="off"

print_help() {
  printf '%s\n' "Install Unreal Tournament: GOTY"
  printf 'Usage: %s [-d|--destination <arg>] [--ui-mode <MODE>] [-k|--(no-)keep-installer-files] [-h|--help] [-v|--version]\n' "$0"
  printf '\t%s\n' "-d, --destination: Install directory. Will be created if it doesn't exist. (default: '${XDG_DATA_DIR:-${HOME}/.local/share}/OldUnreal/UnrealTournament')"
  printf '\t%s\n' "--ui-mode: UI library to use during install.. Can be one of: 'auto', 'kdialog', 'zenity' and 'none' (default: 'auto')"
  printf '\t%s\n' "-k, --keep-installer-files, --no-keep-installer-files: Keep ISO and Patch files. (off by default)"
  printf '\t%s\n' "-h, --help: Prints help"
  printf '\t%s\n' "-v, --version: Prints version"
}

parse_commandline() {
  local _key
  while test $# -gt 0; do
    _key="$1"
    case "$_key" in
    -d | --destination)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_destination="$2"
      shift
      ;;
    --destination=*)
      _arg_destination="${_key##--destination=}"
      ;;
    -d*)
      _arg_destination="${_key##-d}"
      ;;
    --ui-mode)
      test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
      _arg_ui_mode="$(uimode "$2" "ui-mode")" || exit 1
      shift
      ;;
    --ui-mode=*)
      _arg_ui_mode="$(uimode "${_key##--ui-mode=}" "ui-mode")" || exit 1
      ;;
    -k | --no-keep-installer-files | --keep-installer-files)
      _arg_keep_installer_files="on"
      test "${1:0:5}" = "--no-" && _arg_keep_installer_files="off"
      ;;
    -k*)
      _arg_keep_installer_files="on"
      _next="${_key##-k}"
      if test -n "$_next" -a "$_next" != "$_key"; then
        { begins_with_short_option "$_next" && shift && set -- "-k" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
      fi
      ;;
    -h | --help)
      print_help
      exit 0
      ;;
    -h*)
      print_help
      exit 0
      ;;
    -v | --version)
      printf '%s %s\n\n%s\n%s\n' "install-ut99.sh" "1.0" 'Install Unreal Tournament: GOTY' 'OldUnreal <https://oldunreal.com>'
      exit 0
      ;;
    -v*)
      printf '%s %s\n\n%s\n%s\n' "install-ut99.sh" "1.0" 'Install Unreal Tournament: GOTY' 'OldUnreal <https://oldunreal.com>'
      exit 0
      ;;
    *)
      _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
      ;;
    esac
    shift
  done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash
_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || {
  echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2
  exit 2
}
# Validation of values

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# Enable Bash Strict Mode
set -euo pipefail

installer::entrypoint() {
  # Defining Installation Parameters
  local PRODUCT_NAME="Unreal Tournament: GOTY"
  local PRODUCT_SHORTNAME="UnrealTournament"
  local MAIN_BINARY_NAME="ut-bin"

  # Patch Metadata Download Step
  local PATCH_METADATA_URL="https://api.github.com/repos/OldUnreal/UnrealTournamentPatches/releases/latest"

  # Download Steps
  local DOWNLOADS_URL_LIST=(
    "https://files.oldunreal.net/UT_GOTY_CD1.ISO||https://archive.org/download/ut-goty/UT_GOTY_CD1.iso"
    "https://files.oldunreal.net/utbonuspack4-zip.7z||https://github.com/OldUnreal/FullGameInstallers/raw/refs/heads/master/Windows/Installer/utbonuspack4-zip.7z"
  )
  local DOWNLOADS_FILENAME_LIST=(
    "UT_GOTY_CD1.iso"
    "utbonuspack4-zip.7z"
  )
  local DOWNLOADS_SIZE_LIST=(
    649633792
    11268844
  )

  # Game Data Unpacking
  # shellcheck disable=SC2034 # Used dynamically
  local UNPACK_IGNORE_PATTERNS=(
    # Default ini files
    'System/UnrealTournament.ini'
    'System/User.ini'

    # Windows specific binaries
    'System/*.bat'
    'System/*.dll'
    'System/*.exe'

    # Old Setup Files
    'Autorun.inf'
    'Setup.exe'
    'DirectX7'
    'GameSpy'
    'Microsoft'
    'NetGamesUSA.com'
    'System400'

    # Translation Files
    'System/*.ctt'
    'System/*.det'
    'System/*.elt'
    'System/*.est'
    'System/*.frt'
    'System/*.int'
    'System/*.itt'
    'System/*.nlt'
    'System/*.ptt'
    'System/*.rut'
  )

  # Import Library files
  # shellcheck shell=bash
  declare -A ansi_colornum=(
    [black]=0
    [red]=1
    [green]=2
    [yellow]=3
    [blue]=4
    [magenta]=5
    [cyan]=6
    [white]=7
  )

  declare -A ansi_stylenum=(
    [reset]=0
    [bright]=1
    [dim]=2
    [italic]=3
    [underline]=4
    [flash]=5
    [highlight]=7
    [normal]=22
  )

  # UI Mode auto-detection
  if [ -z "${_arg_ui_mode:-}" ] || [ "${_arg_ui_mode:-}" == "auto" ]; then
    if ! { [ -n "${DISPLAY:-}" ] || [ -n "${WAYLAND_DISPLAY:-}" ]; } ||
      { [ -n "${SSH_CLIENT:-}" ] || [ -n "${SSH_TTY:-}" ]; }; then
      # If we do not have a display, or we are in a SSH session, fallback to text mode
      _arg_ui_mode="none"
    elif { [ "${XDG_CURRENT_DESKTOP:-}" == "KDE" ] && command -pv kdialog &>/dev/null && command -pv busctl &>/dev/null; }; then
      # If we are on KDE, and kdialog + busctl is available, use kdialog
      _arg_ui_mode="kdialog"
    elif command -pv zenity &>/dev/null; then
      # Use Zenity if available
      _arg_ui_mode="zenity"
    elif command -pv kdialog &>/dev/null && command -pv busctl &>/dev/null; then
      # If kdialog is available, but zenity is not (outside of KDE)
      _arg_ui_mode="kdialog"
    else
      # If nothing is available, only run in text mode
      _arg_ui_mode="none"
    fi
  fi

  ansi::styled() {
    ALLOW_ESCAPES="off"
    if [ "${1:-}" == "-e" ]; then
      ALLOW_ESCAPES="on"
      shift
    fi

    local TEXT_TO_PRINT="${1:-}"
    local STYLE="${2:--1}"
    local FORE_COLOR="${3:--1}"
    local BACK_COLOR="${4:--1}"

    declare -a CODES RESETCODES
    if [[ "${STYLE}" -eq 22 ]] || [[ "${STYLE}" -eq -1 ]]; then
      RESETCODES=("$(printf "\033[%sm" "22")" "${RESETCODES[@]}")
    else
      CODES=("${CODES[@]}" "$(printf "\033[%sm" "${STYLE}")")
    fi

    if [[ "${BACK_COLOR}" -eq -1 ]]; then
      RESETCODES=("$(printf "\033[%sm" "49")" "${RESETCODES[@]}")
    else
      CODES=("${CODES[@]}" "$(printf "\033[%sm" "$((BACK_COLOR + 40))")")
    fi

    if [[ "${FORE_COLOR}" -eq -1 ]]; then
      RESETCODES=("$(printf "\033[%sm" "39")" "${RESETCODES[@]}")
    else
      CODES=("${CODES[@]}" "$(printf "\033[%sm" "$((FORE_COLOR + 30))")")
    fi

    local rc
    for rc in "${RESETCODES[@]}"; do
      echo -en "$rc"
    done
    local c
    for c in "${CODES[@]}"; do
      echo -en "$c"
    done

    if [ "${ALLOW_ESCAPES}" == "on" ]; then
      echo -en "${TEXT_TO_PRINT}"
    else
      echo -n "${TEXT_TO_PRINT}"
    fi

    echo -en "\033[m"
  }

  ansi::banner() {
    local TOPEDGE BOTTOMEDGE
    TOPEDGE="┏━${1//?/━}━┓"
    BOTTOMEDGE="┗━${1//?/━}━┛"

    printf "%s\n" "$(ansi::styled "${TOPEDGE}" "${ansi_stylenum[bright]}")"
    printf "%s\n" "$(ansi::styled "┃ ${1} ┃" "${ansi_stylenum[bright]}")"
    printf "%s\n" "$(ansi::styled "${BOTTOMEDGE}" "${ansi_stylenum[bright]}")"
  }

  term::error() {
    echo -e "$(ansi::styled "Error:" "${ansi_stylenum[bright]}" "${ansi_colornum[red]}") $*" 1>&2
  }

  term::yesno() {
    local QUESTION="${1:-}"
    local DEFAULT="${2:-N}"

    local DEFAULT_PROMPT="[yN]"
    if [[ "${DEFAULT}" =~ ^[Yy]$ ]]; then
      DEFAULT_PROMPT="[Yn]"
    fi

    # In case the user was impatient and typed a whole bunch of crap in their terminal while waiting for a download
    # clear the STDIN buffer
    if test -t 0; then
      local discard
      read -r -n 1000000 -t 0.001 discard || true

      if [ -n "${discard:-}" ]; then
        echo
      fi
    fi

    read -p "$(ansi::styled "?" "${ansi_stylenum[bright]}" "${ansi_colornum[green]}") ${QUESTION} $(ansi::styled "${DEFAULT_PROMPT}" "${ansi_stylenum[bright]}") " -n 1 -r
    echo
    if [[ "${DEFAULT}" =~ ^[Nn]$ ]]; then
      if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
        return 1
      fi
    elif [[ "${DEFAULT}" =~ ^[Yy]$ ]]; then
      if [[ "$REPLY" =~ ^[Nn]$ ]]; then
        return 1
      fi
    fi

    return 0
  }

  local CURRENT_STEP_NAME=""
  local STEP_PROGRESS_SPINNER_CHARS=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
  local STEP_PROGRESS_SPINNER_CURRENT=0

  term::step::new() {
    CURRENT_STEP_NAME="$*"

    echo -en " $(ansi::styled "[   ]" "${ansi_stylenum[bright]}") $*"
  }

  term::step::replace() {
    CURRENT_STEP_NAME="$*"

    echo -en "\r\033[K $(ansi::styled "[   ]" "${ansi_stylenum[bright]}") $*"
  }

  term::step::progress() {
    local STEP_PROGRESS_TEXT=""

    if [ -n "${1:-}" ]; then
      STEP_PROGRESS_TEXT="$(ansi::styled " ($*)" "${ansi_stylenum[dim]}")"
    fi

    echo -en "\r $(ansi::styled "[" "${ansi_stylenum[bright]}") $(ansi::styled "${STEP_PROGRESS_SPINNER_CHARS[$STEP_PROGRESS_SPINNER_CURRENT]}" "${ansi_stylenum[dim]}") $(ansi::styled "]" "${ansi_stylenum[bright]}") ${CURRENT_STEP_NAME}${STEP_PROGRESS_TEXT}\033[K"
    STEP_PROGRESS_SPINNER_CURRENT=$((STEP_PROGRESS_SPINNER_CURRENT + 1))

    if [ "${STEP_PROGRESS_SPINNER_CURRENT}" -ge "${#STEP_PROGRESS_SPINNER_CHARS[@]}" ]; then
      STEP_PROGRESS_SPINNER_CURRENT=0
    fi
  }

  term::step::complete() {
    echo -e "\r\033[K $(ansi::styled "[" "${ansi_stylenum[bright]}") $(ansi::styled "✓" "${ansi_stylenum[bright]}" "${ansi_colornum[green]}") $(ansi::styled "]" "${ansi_stylenum[bright]}") ${CURRENT_STEP_NAME}"
  }

  term::step::failed() {
    echo -e "\r\033[K $(ansi::styled "[" "${ansi_stylenum[bright]}") $(ansi::styled "✗" "${ansi_stylenum[bright]}" "${ansi_colornum[red]}") $(ansi::styled "]" "${ansi_stylenum[bright]}") ${CURRENT_STEP_NAME}"
  }

  term::step::skipped() {
    local STEP_SKIPPED_REASON=""

    if [ -n "${1:-}" ]; then
      STEP_SKIPPED_REASON="$(ansi::styled " ($*)" "${ansi_stylenum[dim]}")"
    fi

    echo -e "\r\033[K $(ansi::styled "[" "${ansi_stylenum[bright]}") $(ansi::styled "-" "${ansi_stylenum[dim]}") $(ansi::styled "]" "${ansi_stylenum[bright]}") ${CURRENT_STEP_NAME}${STEP_SKIPPED_REASON}"
  }

  term::step::failed_with_error() {
    term::step::failed
    echo

    local ERROR_TEXT="$*"

    term::error "${ERROR_TEXT}" 1>&2

    if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
      kdialog --title "Error" \
        --error "${ERROR_TEXT}" 2>/dev/null
    elif [ "${_arg_ui_mode:-none}" == "zenity" ]; then
      zenity --error --text="${ERROR_TEXT}" --width=350 2>/dev/null
    fi
  }
  # shellcheck shell=bash

  local ARCHITECTURE_SUFFIX UE_SYSTEM_FOLDER_SUFFIX

  case $(uname -m) in
  x86_64)
    ARCHITECTURE_SUFFIX='amd64'
    UE_SYSTEM_FOLDER_SUFFIX='64'
    ;;
  amd64)
    ARCHITECTURE_SUFFIX='amd64'
    UE_SYSTEM_FOLDER_SUFFIX='64'
    ;;
  aarch64)
    ARCHITECTURE_SUFFIX='arm64'
    UE_SYSTEM_FOLDER_SUFFIX='ARM64'
    ;;
  i386)
    ARCHITECTURE_SUFFIX='x86'
    UE_SYSTEM_FOLDER_SUFFIX=''
    ;;
  i686)
    ARCHITECTURE_SUFFIX='x86'
    UE_SYSTEM_FOLDER_SUFFIX=''
    ;;
  *)
    ARCHITECTURE_SUFFIX='NOT_SUPPORTED'
    UE_SYSTEM_FOLDER_SUFFIX=''
    ;;
  esac
  # shellcheck shell=bash

  # Downloader
  local DOWNLOADER_TIMEOUT=15
  local DOWNLOADER_PROGRESS_MIN_REFRESH=0.1
  local DOWNLOADER_BIN=""
  local DOWNLOADER_TYPE=""
  if command -pv "curl" &>/dev/null; then
    DOWNLOADER_BIN="curl"
    DOWNLOADER_TYPE="curl"
  elif command -pv "wget" &>/dev/null; then
    DOWNLOADER_BIN="wget"
    DOWNLOADER_TYPE="wget"

    # Check if provided wget version is Wget2... Thanks Fedora :(
    if [[ "$(wget --version)" =~ " Wget2 " ]]; then
      DOWNLOADER_TYPE="wget2"
    fi
  elif command -pv "wget2" &>/dev/null; then
    DOWNLOADER_BIN="wget2"
    DOWNLOADER_TYPE="wget2"
  fi

  downloader::download_file() {
    if [ -z "${1:-}" ] || [ -z "${2:-}" ]; then
      return 1
    fi

    local DOWNLOAD_URL="${1%%"||"*}"
    local REMAINING_FALLBACKS="${1#*"||"}"

    if [ "${DOWNLOAD_URL}" == "${REMAINING_FALLBACKS}" ]; then
      REMAINING_FALLBACKS=""
    fi

    local DOWNLOAD_PATH="${2}"
    local IS_RETRY="${3:-no}"

    __downloader::download_file "${DOWNLOAD_URL}" "${DOWNLOAD_PATH}" "${IS_RETRY}" || downloader::download_file "${REMAINING_FALLBACKS}" "${DOWNLOAD_PATH}" "yes"
  }

  downloader::fetch_json() {
    local ENDPOINT_URL="${1:-}"

    if [ -z "${ENDPOINT_URL}" ]; then
      return 1
    fi

    local IS_GITHUB_URL="no"
    local RESOLVED_GITHUB_TOKEN=""

    if [[ "${ENDPOINT_URL}" =~ ^https://(github\.com|.+\.github\.com|.+\.githubusercontent\.com)/ ]]; then
      IS_GITHUB_URL="yes"
      RESOLVED_GITHUB_TOKEN="${GITHUB_TOKEN:-${GH_TOKEN:-}}"
    fi

    if [ "${DOWNLOADER_TYPE}" == "curl" ]; then
      local ADDITIONAL_ARGS=()

      if [ "${IS_GITHUB_URL}" == "yes" ] && [ -n "${RESOLVED_GITHUB_TOKEN}" ]; then
        ADDITIONAL_ARGS+=("--header" "Authorization: Bearer ${RESOLVED_GITHUB_TOKEN}")
      fi

      "${DOWNLOADER_BIN}" -Ls "${ADDITIONAL_ARGS[@]}" --connect-timeout "${DOWNLOADER_TIMEOUT}" "${ENDPOINT_URL}" 2>/dev/null
    elif [ "${DOWNLOADER_TYPE}" == "wget" ]; then
      local ADDITIONAL_ARGS=()

      if [ "${IS_GITHUB_URL}" == "yes" ] && [ -n "${RESOLVED_GITHUB_TOKEN}" ]; then
        ADDITIONAL_ARGS+=("--header=Authorization: Bearer ${RESOLVED_GITHUB_TOKEN}")
      fi

      "${DOWNLOADER_BIN}" -q "${ADDITIONAL_ARGS[@]}" --timeout="${DOWNLOADER_TIMEOUT}" "${ENDPOINT_URL}" -O - -o /dev/null 2>/dev/null
    elif [ "${DOWNLOADER_TYPE}" == "wget2" ]; then
      local ADDITIONAL_ARGS=()

      if [ "${IS_GITHUB_URL}" == "yes" ] && [ -n "${RESOLVED_GITHUB_TOKEN}" ]; then
        ADDITIONAL_ARGS+=("--header=Authorization: Bearer ${RESOLVED_GITHUB_TOKEN}")
      fi

      "${DOWNLOADER_BIN}" -q "${ADDITIONAL_ARGS[@]}" --timeout="${DOWNLOADER_TIMEOUT}" "${ENDPOINT_URL}" -O - -o /dev/null 2>/dev/null
    fi
  }

  __downloader::download_file() {
    local DOWNLOAD_URL="${1:-}"
    local DOWNLOAD_PATH="${2:-}"
    local IS_RETRY="${3:-no}"

    if [ -z "${DOWNLOAD_URL}" ] || [ -z "${DOWNLOAD_PATH}" ]; then
      return 1
    fi

    local DOWNLOAD_FILE="${DOWNLOAD_PATH##*/}"

    if [ "${IS_RETRY}" == "no" ]; then
      term::step::new "Download ${DOWNLOAD_FILE}"
      term::step::progress "Starting..."
    else
      term::step::new "Download ${DOWNLOAD_FILE} (retry)"
    fi

    local DOWNLOAD_PROGRESS

    exec 6<&0

    local KDIALOG_DBUS_ADDRESS=()

    if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
      read -ra KDIALOG_DBUS_ADDRESS < <(kdialog --title "${CURRENT_STEP_NAME}" --progressbar "Starting download..." 0 2>/dev/null)
    fi

    __downloader::download_file_with_progress "${DOWNLOAD_URL}" "${DOWNLOAD_PATH}" | while IFS= read -r DOWNLOAD_PROGRESS; do
      if [ -z "${DOWNLOAD_PROGRESS}" ]; then
        term::step::progress "Starting..." >&6

        if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
          busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "setLabelText" s "Starting Download..." 2>/dev/null || break
          busctl --user set-property "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "maximum" i 0 2>/dev/null || break
        fi
        continue
      fi

      DOWNLOAD_PROGRESS="${DOWNLOAD_PROGRESS#*|}"

      local TOTAL_SIZE="${DOWNLOAD_PROGRESS%%|*}"
      DOWNLOAD_PROGRESS="${DOWNLOAD_PROGRESS#*|}"

      local CURRENT_PROGRESS="${DOWNLOAD_PROGRESS%%|*}"
      DOWNLOAD_PROGRESS="${DOWNLOAD_PROGRESS#*|}"

      local RECEIVED="${DOWNLOAD_PROGRESS%%|*}"
      DOWNLOAD_PROGRESS="${DOWNLOAD_PROGRESS#*|}"

      local SPEED="${DOWNLOAD_PROGRESS%%|*}"

      term::step::progress "${CURRENT_PROGRESS}% @ ${SPEED}/s" >&6

      local DIALOG_TEXT="Downloading ${DOWNLOAD_FILE}\n${RECEIVED}"

      if [ -n "${TOTAL_SIZE:-}" ]; then
        DIALOG_TEXT="${DIALOG_TEXT} of ${TOTAL_SIZE} (${CURRENT_PROGRESS}%)"
      else
        DIALOG_TEXT="${DIALOG_TEXT} downloaded (${CURRENT_PROGRESS}%)"
      fi

      DIALOG_TEXT="${DIALOG_TEXT}\nSpeed : ${SPEED}/s"

      if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
        local ESCAPED_DIALOG_TEXT
        ESCAPED_DIALOG_TEXT="$(echo -e "${DIALOG_TEXT}")"
        busctl --user set-property "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "maximum" i 100 2>/dev/null || break
        busctl --user set-property "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "value" i "${CURRENT_PROGRESS}" 2>/dev/null || break
        busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "setLabelText" s "${ESCAPED_DIALOG_TEXT}" 2>/dev/null || break

        # Check for cancellation
        local WAS_CANCELLED
        WAS_CANCELLED="$(busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "wasCancelled" 2>/dev/null || echo "b true")"

        if [ "${WAS_CANCELLED}" == "b true" ]; then
          break
        fi
      elif [ "${_arg_ui_mode:-none}" == "zenity" ]; then
        echo "${CURRENT_PROGRESS}"
        echo "# ${DIALOG_TEXT}"
      fi
    done | {
      if [ "${_arg_ui_mode:-none}" == "zenity" ]; then
        zenity --progress --percentage=0 --text="Starting download..." --time-remaining --auto-close 2>/dev/null
      else
        cat - >/dev/null
      fi
    }

    local DOWNLOAD_STATUS="${PIPESTATUS[0]}"

    exec 0<&6 6<&-

    if [ "${DOWNLOAD_STATUS}" -ne 0 ]; then
      if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
        busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "close" 2>/dev/null || true
      fi

      term::step::failed
      return "${DOWNLOAD_STATUS}"
    fi

    if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
      busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "close" 2>/dev/null || true
    fi

    term::step::complete
  }

  # This function throttles the output to avoid buffering, while also making sure the last update
  # is repeated at a set frequency for the throbber to work
  __downloader::download_file_with_progress() {
    local DOWNLOAD_URL="${1:-}"
    local DOWNLOAD_PATH="${2:-}"

    if [ -z "${DOWNLOAD_URL}" ] || [ -z "${DOWNLOAD_PATH}" ]; then
      return 1
    fi

    local LAST_UPDATE=""
    local CURRENT_UPDATE=""

    exec 3< <(__downloader::download_file_with_progress::raw "${DOWNLOAD_URL}" "${DOWNLOAD_PATH}")
    local PROC_SUB_PID=$!

    trap '[ -n "${PROC_SUB_PID:-}" ] && { kill -- "${PROC_SUB_PID}"; }' EXIT

    local CAN_WRITE="y"
    trap 'CAN_WRITE="n"' SIGPIPE

    while kill -0 "${PROC_SUB_PID}" 2>/dev/null; do
      while IFS= read -r -u 3 -t 0.001 CURRENT_UPDATE; do
        LAST_UPDATE="${CURRENT_UPDATE}"
      done

      if [ "${CAN_WRITE}" == "y" ]; then
        echo "${LAST_UPDATE}" 2>/dev/null
        sleep "${DOWNLOADER_PROGRESS_MIN_REFRESH}"
      else
        break
      fi
    done

    trap - SIGPIPE EXIT

    local EXIT_CODE=1

    if [ "${CAN_WRITE}" == "y" ]; then
      # Final drain of remaining data
      while IFS= read -r -u 3 CURRENT_UPDATE; do
        LAST_UPDATE="${CURRENT_UPDATE}"
      done
      echo "${LAST_UPDATE}"
    else
      if kill -0 "${PROC_SUB_PID}" 2>/dev/null; then
        # Explicitly kill if the loop exited due to CAN_WRITE="n"
        kill -TERM -- "${PROC_SUB_PID}"
      fi

      return 1
    fi

    wait "${PROC_SUB_PID}"
    EXIT_CODE=$?

    exec 3<&-
    return "${EXIT_CODE}"
  }

  # This function parses the output of the various downloaders to report status information
  __downloader::download_file_with_progress::raw() {
    local DOWNLOAD_URL="${1:-}"
    local DOWNLOAD_PATH="${2:-}"

    if [ -z "${DOWNLOAD_URL}" ] || [ -z "${DOWNLOAD_PATH}" ]; then
      return 1
    fi

    local DOWNLOAD_FILE="${DOWNLOAD_PATH##*/}"

    local TRANSFER_PROGRESS=""

    local IS_GITHUB_URL="no"
    local RESOLVED_GITHUB_TOKEN=""

    if [[ "${DOWNLOAD_URL}" =~ ^https://(github\.com|.+\.github\.com|.+\.githubusercontent\.com)/ ]]; then
      IS_GITHUB_URL="yes"
      RESOLVED_GITHUB_TOKEN="${GITHUB_TOKEN:-${GH_TOKEN:-}}"
    fi

    set -m
    {
      if [ "${DOWNLOADER_TYPE}" == "curl" ]; then
        #                                  %                   Total          %            Received         %            Xfered        AvgSpdDown          AvgSpdUp  Time Total  Time Spent  Time Left   Current Speed
        local CURL_CAPTURE_REGEX='^\s*[0-9]+\s+([1-9][0-9.]*[kKMGT]?)\s+([0-9]+)\s+([0-9.]+[kKMGT]?)\s+[0-9]+\s+[0-9.]+[kKMGT]?\s+[0-9.]+[kKMGT]?\s+[0-9.]+[kKMGT]?\s+[-0-9:]+\s+[-0-9:]+\s+[-0-9:]+\s+([0-9.]+[kKMGT]?)\s*$'
        local ADDITIONAL_ARGS=()

        if [ "${IS_GITHUB_URL}" == "yes" ] && [ -n "${RESOLVED_GITHUB_TOKEN}" ]; then
          ADDITIONAL_ARGS+=("--header" "Authorization: Bearer ${RESOLVED_GITHUB_TOKEN}")
        fi

        "${DOWNLOADER_BIN}" -LN --progress-meter "${ADDITIONAL_ARGS[@]}" --connect-timeout "${DOWNLOADER_TIMEOUT}" "${DOWNLOAD_URL}" -o "${DOWNLOAD_PATH}" 2>&1 |
          stdbuf -oL -- tr '\r' '\n' |
          while IFS= read -r TRANSFER_PROGRESS; do
            if [[ "${TRANSFER_PROGRESS}" =~ ${CURL_CAPTURE_REGEX} ]]; then
              echo "${DOWNLOAD_FILE}|${BASH_REMATCH[1]}|${BASH_REMATCH[2]}|${BASH_REMATCH[3]}|${BASH_REMATCH[4]}"
            fi
          done
        return "${PIPESTATUS[0]}"
      elif [ "${DOWNLOADER_TYPE}" == "wget" ]; then
        local WGET_LENGTH_CAPTURE_REGEX='^Length:\s+[0-9]+\s+\((.*)\).*$'
        local WGET_CAPTURE_REGEX='^\s*([0-9.]+[BKMG])\s+[. ]+\s+([0-9]+)%\s+([0-9.]+[BKMG])\s+.*$'
        local TOTAL_SIZE
        local ADDITIONAL_ARGS=()

        if [ "${IS_GITHUB_URL}" == "yes" ] && [ -n "${RESOLVED_GITHUB_TOKEN}" ]; then
          ADDITIONAL_ARGS+=("--header=Authorization: Bearer ${RESOLVED_GITHUB_TOKEN}")
        fi

        "${DOWNLOADER_BIN}" --progress=dot "${ADDITIONAL_ARGS[@]}" --timeout="${DOWNLOADER_TIMEOUT}" "${DOWNLOAD_URL}" -O "${DOWNLOAD_PATH}" -o - 2>&1 |
          while IFS= read -r TRANSFER_PROGRESS; do
            if [[ "${TRANSFER_PROGRESS}" =~ ${WGET_LENGTH_CAPTURE_REGEX} ]]; then
              TOTAL_SIZE="${BASH_REMATCH[1]}"
            elif [[ "${TRANSFER_PROGRESS}" =~ ${WGET_CAPTURE_REGEX} ]]; then
              echo "${DOWNLOAD_FILE}|${TOTAL_SIZE}|${BASH_REMATCH[2]}|${BASH_REMATCH[1]}|${BASH_REMATCH[3]}"
            fi
          done
        return "${PIPESTATUS[0]}"
      elif [ "${DOWNLOADER_TYPE}" == "wget2" ]; then
        local WGET2_CAPTURE_REGEX='^\[1G.+\s+([0-9]+)%\s+\[.+\]\s+([0-9.]+[BKMG])\s+([0-9.]+[BKMG])(B?/s)?\s*$'
        local ADDITIONAL_ARGS=()

        if [ "${IS_GITHUB_URL}" == "yes" ] && [ -n "${RESOLVED_GITHUB_TOKEN}" ]; then
          ADDITIONAL_ARGS+=("--header=Authorization: Bearer ${RESOLVED_GITHUB_TOKEN}")
        fi

        "${DOWNLOADER_BIN}" --progress=bar --force-progress "${ADDITIONAL_ARGS[@]}" --timeout="${DOWNLOADER_TIMEOUT}" "${DOWNLOAD_URL}" -O "${DOWNLOAD_PATH}" 2>&1 |
          stdbuf -oL -- tr '\r\033' '\n\n' |
          while IFS= read -r TRANSFER_PROGRESS; do
            if [[ "${TRANSFER_PROGRESS}" =~ ${WGET2_CAPTURE_REGEX} ]]; then
              echo "${DOWNLOAD_FILE}||${BASH_REMATCH[1]}|${BASH_REMATCH[2]}|${BASH_REMATCH[3]}"
            fi
          done
        return "${PIPESTATUS[0]}"
      fi
    } &
    set +m
    local PROC_SUB_PID=$!

    trap 'trap - EXIT; [ -n "${PROC_SUB_PID:-}" ] && { kill -- -"${PROC_SUB_PID}"; wait "${PROC_SUB_PID}"; return $?; }' EXIT

    wait "${PROC_SUB_PID}"
    local EXIT_CODE=$?
    trap - EXIT
    return $?
  }
  # shellcheck shell=bash

  local UNARCHIVER_BIN=""
  if command -pv "7z" &>/dev/null; then
    UNARCHIVER_BIN="7z"
  elif command -pv "7zz" &>/dev/null; then
    UNARCHIVER_BIN="7zz"
  fi

  unarchiver::unarchive_file() {
    local ITEM_NAME="${1:-}"
    local ARCHIVE_PATH="${2:-}"
    local TARGET_PATH="${3:-}"
    local IGNORE_PATTERNS_VAR_NAME="${4:-}"
    local IGNORE_PATTERNS_RECURSIVE_VAR_NAME="${5:-}"

    if [ -z "${ARCHIVE_PATH}" ] || [ -z "${TARGET_PATH}" ]; then
      return 1
    fi

    if [ ! -f "${ARCHIVE_PATH}" ]; then
      return 1
    fi

    term::step::new "Extract ${ITEM_NAME}"

    local UNARCHIVE_PROGRESS

    exec 6<&0

    local KDIALOG_DBUS_ADDRESS=()

    if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
      read -ra KDIALOG_DBUS_ADDRESS < <(kdialog --title "${CURRENT_STEP_NAME}" --progressbar "Extracting ${ITEM_NAME}..." 0 2>/dev/null)
      busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "showCancelButton" b "false" 2>/dev/null || true
    fi

    __unarchiver::unarchive_file_with_progress "${ARCHIVE_PATH}" "${TARGET_PATH}" "${IGNORE_PATTERNS_VAR_NAME}" "${IGNORE_PATTERNS_RECURSIVE_VAR_NAME}" |
      while IFS= read -r UNARCHIVE_PROGRESS; do
        if [ -z "${UNARCHIVE_PROGRESS}" ]; then
          term::step::progress "" >&6

          if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
            busctl --user set-property "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "maximum" i 0 2>/dev/null || true
          fi
          continue
        fi

        term::step::progress "${UNARCHIVE_PROGRESS}%" >&6

        local DIALOG_TEXT="Extracting ${ITEM_NAME} (${UNARCHIVE_PROGRESS}%)"

        if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
          local ESCAPED_DIALOG_TEXT
          ESCAPED_DIALOG_TEXT="$(echo -e "${DIALOG_TEXT}")"
          busctl --user set-property "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "maximum" i 100 2>/dev/null || true
          busctl --user set-property "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "value" i "${UNARCHIVE_PROGRESS}" 2>/dev/null || true
          busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "setLabelText" s "${ESCAPED_DIALOG_TEXT}" 2>/dev/null || true
        elif [ "${_arg_ui_mode:-none}" == "zenity" ]; then
          echo "${UNARCHIVE_PROGRESS}"
          echo "# ${DIALOG_TEXT}"
        fi
      done | {
      if [ "${_arg_ui_mode:-none}" == "zenity" ]; then
        zenity --progress --percentage=0 --text="Extracting ${ITEM_NAME}..." --no-cancel --time-remaining --auto-close 2>/dev/null
      else
        cat - >/dev/null
      fi
    }

    local UNARCHIVE_STATUS="${PIPESTATUS[0]}"

    exec 0<&6 6<&-

    if [ "${UNARCHIVE_STATUS}" -ne 0 ]; then
      if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
        busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "close" 2>/dev/null || true
      fi

      term::step::failed
      return "${UNARCHIVE_STATUS}"
    fi

    if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
      busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "close" 2>/dev/null || true
    fi

    term::step::complete
  }

  __unarchiver::unarchive_file_with_progress() {
    local ARCHIVE_PATH="${1:-}"
    local TARGET_PATH="${2:-}"
    local IGNORE_PATTERNS_VAR_NAME="${3:-}"
    local IGNORE_PATTERNS_RECURSIVE_VAR_NAME="${4:-}"

    if [ -z "${ARCHIVE_PATH}" ] || [ -z "${TARGET_PATH}" ]; then
      return 1
    fi

    local LAST_UPDATE=""
    local CURRENT_UPDATE=""

    exec 3< <(__unarchiver::unarchive_file_with_progress::raw "${ARCHIVE_PATH}" "${TARGET_PATH}" "${IGNORE_PATTERNS_VAR_NAME}" "${IGNORE_PATTERNS_RECURSIVE_VAR_NAME}")
    local PROC_SUB_PID=$!

    trap '[ -n "${PROC_SUB_PID:-}" ] && { kill -- "${PROC_SUB_PID}"; }' EXIT

    local CAN_WRITE="y"
    trap 'CAN_WRITE="n"' SIGPIPE

    while kill -0 "${PROC_SUB_PID}" 2>/dev/null; do
      while IFS= read -r -u 3 -t 0.001 CURRENT_UPDATE; do
        LAST_UPDATE="${CURRENT_UPDATE}"
      done

      if [ "${CAN_WRITE}" == "y" ]; then
        echo "${LAST_UPDATE}" 2>/dev/null
        sleep "${DOWNLOADER_PROGRESS_MIN_REFRESH}"
      else
        break
      fi
    done

    trap - SIGPIPE EXIT

    local EXIT_CODE=1

    if [ "${CAN_WRITE}" == "y" ]; then
      # Final drain of remaining data
      while IFS= read -r -u 3 CURRENT_UPDATE; do
        LAST_UPDATE="${CURRENT_UPDATE}"
      done
      echo "${LAST_UPDATE}"
    else
      if kill -0 "${PROC_SUB_PID}" 2>/dev/null; then
        # Explicitly kill if the loop exited due to CAN_WRITE="n"
        kill -TERM -- "${PROC_SUB_PID}"
      fi

      return 1
    fi

    wait "${PROC_SUB_PID}"
    EXIT_CODE=$?

    exec 3<&-
    return "${EXIT_CODE}"
  }

  __unarchiver::unarchive_file_with_progress::raw() {
    local ARCHIVE_PATH="${1:-}"
    local TARGET_PATH="${2:-}"
    local IGNORE_PATTERNS_VAR_NAME="${3:-}"
    local IGNORE_PATTERNS_RECURSIVE_VAR_NAME="${4:-}"

    if [ -z "${ARCHIVE_PATH}" ] || [ -z "${TARGET_PATH}" ]; then
      return 1
    fi

    local UNARCHIVE_PROGRESS=""
    set -m
    {
      local SEVENZ_REGEX='^\s*([0-9]+)%'

      __unarchiver::unarchive_file::call_7z \
        "${ARCHIVE_PATH}" "${TARGET_PATH}" \
        "${IGNORE_PATTERNS_VAR_NAME}" "${IGNORE_PATTERNS_RECURSIVE_VAR_NAME}" |
        stdbuf -oL -- tr $'\b\r' $'\n\n' |
        while IFS= read -r UNARCHIVE_PROGRESS; do
          if [[ "${UNARCHIVE_PROGRESS}" =~ ${SEVENZ_REGEX} ]]; then
            echo "${BASH_REMATCH[1]}"
          fi
        done
      return "${PIPESTATUS[0]}"
    } &
    set +m
    local PROC_SUB_PID=$!

    trap 'trap - EXIT; [ -n "${PROC_SUB_PID:-}" ] && { kill -- -"${PROC_SUB_PID}"; wait "${PROC_SUB_PID}"; return $?; }' EXIT

    wait "${PROC_SUB_PID}"
    local EXIT_CODE=$?
    trap - EXIT
    return $?
  }

  __unarchiver::unarchive_file::call_7z() {
    local ARCHIVE_PATH="${1:-}"
    local TARGET_PATH="${2:-}"

    if [ -z "${ARCHIVE_PATH}" ] || [ -z "${TARGET_PATH}" ]; then
      return 1
    fi

    local ARCHIVE_FILENAME="${ARCHIVE_PATH##*/}"

    local IGNORE_PATTERNS=()
    local IGNORE_PATTERNS_VAR_NAME="${3:-}"
    if [ -n "${IGNORE_PATTERNS_VAR_NAME}" ]; then
      local IGNORE_PATTERN_VAR_REF="${IGNORE_PATTERNS_VAR_NAME}[@]"
      IGNORE_PATTERNS=("${!IGNORE_PATTERN_VAR_REF}")
    fi

    local IGNORE_PATTERNS_RECURSIVE=()
    local IGNORE_PATTERNS_RECURSIVE_VAR_NAME="${4:-}"
    if [ -n "${IGNORE_PATTERNS_RECURSIVE_VAR_NAME}" ]; then
      local IGNORE_PATTERN_RECURSIVE_VAR_REF="${IGNORE_PATTERNS_RECURSIVE_VAR_NAME}[@]"
      IGNORE_PATTERNS_RECURSIVE=("${!IGNORE_PATTERN_RECURSIVE_VAR_REF}")
    fi

    local IS_TARBALL="n"

    case "${ARCHIVE_FILENAME}" in
    *.tar.gz | *.tgz)
      IS_TARBALL="y"
      ;;
    *.tar.bz2 | *.tbz)
      IS_TARBALL="y"
      ;;
    *.tar.xz | *.txz)
      IS_TARBALL="y"
      ;;
    *.tar.zst | *.tar.zstd)
      IS_TARBALL="y"
      ;;
    esac

    local SEZENZ_ARGS=()
    local SEZENZ_OUTER_ARGS=()

    if [ "${IS_TARBALL}" == "y" ]; then
      SEZENZ_OUTER_ARGS=("x" "${ARCHIVE_PATH}" "-y" "-bsp0" "-bso0" "-bse2" "-so")
      SEZENZ_ARGS=("x" "-si" "-ttar" "-y" "-bsp1" "-bso0" "-bse0" "-o${TARGET_PATH}")
    else
      SEZENZ_ARGS=("x" "${ARCHIVE_PATH}" "-y" "-bsp1" "-bso0" "-bse0" "-o${TARGET_PATH}")
    fi

    local IGNORE
    for IGNORE in "${IGNORE_PATTERNS[@]}"; do
      SEZENZ_ARGS+=("-x!${IGNORE}")
    done

    for IGNORE in "${IGNORE_PATTERNS_RECURSIVE[@]}"; do
      SEZENZ_ARGS+=("-xr!${IGNORE}")
    done

    if [ "${IS_TARBALL}" == "y" ]; then
      "${UNARCHIVER_BIN}" "${SEZENZ_OUTER_ARGS[@]}" | "${UNARCHIVER_BIN}" "${SEZENZ_ARGS[@]}"
    else
      "${UNARCHIVER_BIN}" "${SEZENZ_ARGS[@]}"
    fi
  }

  # shellcheck shell=bash

  step::welcome_banner() {
    ansi::banner "OldUnreal ${PRODUCT_NAME} Linux Installer"
    echo

    if [ "${_arg_ui_mode:-none}" != "none" ]; then
      echo -e "$(ansi::styled "Installer is running in GUI mode. If no window is displayed," "${ansi_stylenum[dim]}")"
      echo -e "$(ansi::styled "type " "${ansi_stylenum[dim]}")CTRL+C$(ansi::styled " to kill the installer, and start it with the" "${ansi_stylenum[dim]}")"
      echo -e "--ui-mode=none$(ansi::styled " argument." "${ansi_stylenum[dim]}")"
      echo
    fi
  }
  step::welcome_banner

  # shellcheck shell=bash

  step::check_dependencies() {
    term::step::new "Checking Dependencies"

    if [ "${ARCHITECTURE_SUFFIX:-NOT_SUPPORTED}" == 'NOT_SUPPORTED' ]; then
      term::step::failed_with_error "CPU Architecture $(uname -m) is not currently supported."
      return 1
    fi

    local MISSING_DEPS=()
    local MISSING_DEPS_RHEL=()
    local MISSING_DEPS_DEB=()
    local MISSING_DEPS_ARCH=()
    local MISSING_DEPS_OPENSUSE=()
    local MISSING_DEPS_BREW=()

    local UI_MODE_DEPS_MET="yes"

    # Check UI Mode Dependencies
    if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
      term::step::progress "kdialog"
      if ! command -pv "kdialog" &>/dev/null; then
        MISSING_DEPS+=("kdialog")
        MISSING_DEPS_RHEL+=("kdialog")
        MISSING_DEPS_DEB+=("kdialog")
        MISSING_DEPS_ARCH+=("kdialog")
        MISSING_DEPS_OPENSUSE+=("kdialog")

        UI_MODE_DEPS_MET="no"
      fi

      term::step::progress "busctl"
      if ! command -pv "busctl" &>/dev/null; then
        MISSING_DEPS+=("systemd")
        MISSING_DEPS_RHEL+=("systemd")
        MISSING_DEPS_DEB+=("systemd")
        MISSING_DEPS_ARCH+=("systemd")
        MISSING_DEPS_OPENSUSE+=("systemd")

        UI_MODE_DEPS_MET="no"
      fi
    elif [ "${_arg_ui_mode:-none}" == "zenity" ]; then
      term::step::progress "zenity"
      if ! command -pv "zenity" &>/dev/null; then
        MISSING_DEPS+=("zenity")
        MISSING_DEPS_RHEL+=("zenity")
        MISSING_DEPS_DEB+=("zenity")
        MISSING_DEPS_ARCH+=("zenity")
        MISSING_DEPS_OPENSUSE+=("zenity")
        MISSING_DEPS_BREW+=("zenity")

        UI_MODE_DEPS_MET="no"
      fi
    fi

    # Check Downloaders
    term::step::progress "curl"
    if ! command -pv "curl" &>/dev/null &&
      ! command -pv "wget" &>/dev/null &&
      ! command -pv "wget2" &>/dev/null; then
      MISSING_DEPS+=("curl (or wget)")
      MISSING_DEPS_RHEL+=("curl")
      MISSING_DEPS_DEB+=("curl")
      MISSING_DEPS_ARCH+=("curl")
      MISSING_DEPS_OPENSUSE+=("curl")
      MISSING_DEPS_BREW+=("curl")
    fi

    # Check Archivers
    term::step::progress "7zip"
    if ! command -pv "7z" &>/dev/null &&
      ! command -pv "7zz" &>/dev/null; then
      MISSING_DEPS+=("7zip, p7zip-full [Debian], or 7zip-standalone-all [Fedora/RHEL]")
      MISSING_DEPS_RHEL+=("7zip-standalone-all")
      MISSING_DEPS_DEB+=("p7zip-full")
      MISSING_DEPS_ARCH+=("7zip")
      MISSING_DEPS_OPENSUSE+=("7zip")
      MISSING_DEPS_BREW+=("7zip")
    fi

    # Check jq
    term::step::progress "jq"
    if ! command -pv "jq" &>/dev/null; then
      MISSING_DEPS+=("jq")
      MISSING_DEPS_RHEL+=("jq")
      MISSING_DEPS_DEB+=("jq")
      MISSING_DEPS_ARCH+=("jq")
      MISSING_DEPS_OPENSUSE+=("jq")
      MISSING_DEPS_BREW+=("jq")
    fi

    if [ "${UI_MODE_DEPS_MET}" == "no" ]; then
      _arg_ui_mode="none"
    fi

    if [ "${#MISSING_DEPS[@]}" -gt 0 ]; then
      local DISTRO_DERIVATIVE=""
      local DISTRO_PKG_INSTALL_CMD=""

      if command -pv "pacman" &>/dev/null; then
        DISTRO_DERIVATIVE="Arch"
        DISTRO_PKG_INSTALL_CMD="sudo pacman -S ${MISSING_DEPS_ARCH[*]}"
      elif command -pv "dnf" &>/dev/null; then
        DISTRO_DERIVATIVE="Fedora/RHEL"
        DISTRO_PKG_INSTALL_CMD="sudo dnf install ${MISSING_DEPS_RHEL[*]}"
      elif command -pv "apt" &>/dev/null; then
        DISTRO_DERIVATIVE="Debian"
        DISTRO_PKG_INSTALL_CMD="sudo apt install ${MISSING_DEPS_DEB[*]}"
      elif command -pv "zypper" &>/dev/null; then
        DISTRO_DERIVATIVE="OpenSUSE"
        DISTRO_PKG_INSTALL_CMD="sudo zypper install ${MISSING_DEPS_OPENSUSE[*]}"
      fi

      local ERROR_TEXT="Missing required dependencies.\n\nYour system is missing dependencies that are required by this installer.\nPlease install the following required packages:"

      local PKG
      for PKG in "${MISSING_DEPS[@]}"; do
        ERROR_TEXT="${ERROR_TEXT}\n  - ${PKG}"
      done

      if [ -n "${DISTRO_DERIVATIVE}" ]; then
        ERROR_TEXT="${ERROR_TEXT}\n\nOn ${DISTRO_DERIVATIVE} or derivatives, you should be able to install"
        ERROR_TEXT="${ERROR_TEXT}\nthe required package(s) using the following command:\n"
        ERROR_TEXT="${ERROR_TEXT}\n  ${DISTRO_PKG_INSTALL_CMD}"
      fi

      if command -pv "brew" &>/dev/null && [ "${#MISSING_DEPS_BREW[@]}" -gt 0 ]; then
        local BREW_INSTALL_CMD="brew install"

        for PKG in "${MISSING_DEPS_BREW[@]}"; do
          BREW_INSTALL_CMD="${BREW_INSTALL_CMD} ${PKG}"
        done

        ERROR_TEXT="${ERROR_TEXT}\n\nYou appear to have brew installed. Some of the required packages are available\n"
        ERROR_TEXT="${ERROR_TEXT}\non brew. You can install them using the following command:\n"
        ERROR_TEXT="${ERROR_TEXT}\n  ${BREW_INSTALL_CMD}"
      fi

      term::step::failed_with_error "${ERROR_TEXT}"

      if [ "${UI_MODE_DEPS_MET}" == "no" ]; then
        echo 1>&2
        echo "You do not have the required dependencies for the selected UI mode." 1>&2
        echo -e "Please relaunch using the $(ansi::styled "--ui-mode=none" "${ansi_stylenum[bright]}") argument," 1>&2
        echo "or install the required dependencies." 1>&2
      fi

      return 1
    else
      term::step::complete
    fi
  }
  step::check_dependencies

  # shellcheck shell=bash

  local DESTINATION_HOMIFIED=""

  step::check_destination() {
    term::step::new "Checking Destination Folder"

    if [ -z "${_arg_destination:-}" ]; then
      term::step::failed_with_error "No destination folder set. Aborting installation."
      return 78
    fi

    if [ -d "${_arg_destination}" ] && [ ! -w "${_arg_destination}" ]; then
      term::step::failed_with_error "Destination folder not writable by user. Aborting installation."
      return 77 #E_PERM
    elif [ ! -d "${_arg_destination}" ]; then
      # Create folder if it doesn't exist
      mkdir -p "${_arg_destination}" &>/dev/null || {
        term::step::failed_with_error "User does not have permission to create destination folder. Aborting installation."
        return 77 #E_PERM
      }
    fi

    _arg_destination="$(realpath "${_arg_destination}")"

    if [ ! -d "${_arg_destination%/}/Installer" ]; then
      # Create the installation folder
      mkdir -p "${_arg_destination%/}/Installer" &>/dev/null || {
        term::step::failed_with_error "User does not have permission to create destination folder. Aborting installation."
        return 77 #E_PERM
      }
    fi

    if [ ! -w "${_arg_destination%/}/Installer" ]; then
      term::step::failed_with_error "The ./Installer subfolder of the destination cannot be written by this user."
      return 77 #E_PERM
    fi

    DESTINATION_HOMIFIED="${_arg_destination}"
    { [[ "${DESTINATION_HOMIFIED}" =~ ^"${HOME}"(/|$) ]] && DESTINATION_HOMIFIED="~${_arg_destination#"${HOME}"}"; } || true

    term::step::complete
  }
  step::check_destination

  # shellcheck shell=bash

  local EPIC_TOS_URL="https://legal.epicgames.com/en-US/epicgames/tos"

  step::eula() {
    if [ "${_arg_ui_mode:-none}" == "none" ]; then
      __step::eula::text
      return 0
    fi

    term::step::new "Terms of Service"

    local DIALOG_TEXT="The Epic Games Terms of Service apply to the use and distribution of this game,
and they supersede any other end user agreements that may accompany the game.

You may read the Terms of Service at this URL:
  ${EPIC_TOS_URL}"

    local DIALOG_ARGS=()

    if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
      DIALOG_ARGS=(
        kdialog
        --title
        "Terms of Service"
        --yesno
        "${DIALOG_TEXT}"
      )
    elif [ "${_arg_ui_mode:-none}" == "zenity" ]; then
      DIALOG_ARGS=(
        zenity
        --text-info
        "Terms of Service"
        "--checkbox=I agree to Epic Games Terms of Service"
        --width=450
        --height=400
      )
    fi

    if ! echo "${DIALOG_TEXT}" | "${DIALOG_ARGS[@]}" &>/dev/null; then
      term::step::failed_with_error "Installation Aborted." 1>&2
      return 1
    fi

    term::step::complete
  }

  __step::eula::text() {
    echo
    echo -e "The $(ansi::styled "Epic Games Terms of Service" "${ansi_stylenum[bright]}") apply to the use and distribution of this game,"
    echo "and they supersede any other end user agreements that may accompany the game."
    echo
    echo "You may read the Terms of Service at this URL:"
    echo "  $(ansi::styled "${EPIC_TOS_URL}" "${ansi_stylenum[underline]}")"
    echo

    if ! term::yesno "Do you agree to the Terms of Service?"; then
      echo
      term::step::new "Terms of Service"
      term::step::failed_with_error "Installation Aborted." 1>&2
      return 1
    fi

    echo
    term::step::new "Terms of Service"
    term::step::complete
  }
  step::eula

  # shellcheck shell=bash

  local PATCH_FILENAME

  step::read_patch_meta_from_github() {
    term::step::new "Fetch Patch Info from GitHub"

    if [ -z "${PATCH_METADATA_URL:-}" ]; then
      term::step::failed_with_error "Implementation error, PATCH_METADATA_URL not set."
      return 1
    fi

    term::step::progress "Downloading Metadata"
    local PATCH_METADATA_JSON
    { PATCH_METADATA_JSON=$(downloader::fetch_json "${PATCH_METADATA_URL}"); } ||
      {
        term::step::failed_with_error "Failed to read patch metadata from GitHub. Installation aborted."
        return 1
      }

    if ! type "step::read_patch_meta_from_github::metadata_filter" &>/dev/null; then
      step::read_patch_meta_from_github::metadata_filter() {
        echo "-linux-${ARCHITECTURE_SUFFIX}"
      }
    fi

    local JQ_FILTER
    { JQ_FILTER='.assets[] | select(.browser_download_url | ascii_downcase | contains("'$(step::read_patch_meta_from_github::metadata_filter)'"))'; } ||
      {
        term::step::failed_with_error "Implementation error, step::read_patch_meta_from_github::metadata_filter runtime error."
        return 1
      }

    local PATCH_DOWNLOAD_URL
    { PATCH_DOWNLOAD_URL=$(echo "${PATCH_METADATA_JSON}" | jq -r "[ ${JQ_FILTER} ] | .[0].browser_download_url"); } ||
      {
        term::step::failed_with_error "Implementation error, step::read_patch_meta_from_github::metadata_filter runtime error."
        return 1
      }

    if [ -z "${PATCH_DOWNLOAD_URL:-}" ]; then
      term::step::failed_with_error "Couldn't determine which patch to download. Installation aborted."
      return 1
    fi

    PATCH_FILENAME="${PATCH_DOWNLOAD_URL##*/}"
    PATCH_FILENAME="${PATCH_FILENAME%%\?*}"

    local PATCH_DOWNLOAD_SIZE
    { PATCH_DOWNLOAD_SIZE=$(echo "${PATCH_METADATA_JSON}" | jq -r "[ ${JQ_FILTER} ] | .[0].size"); } ||
      {
        term::step::failed_with_error "Couldn't determine patch size. Installation aborted."
        return 1
      }

    DOWNLOADS_URL_LIST+=("${PATCH_DOWNLOAD_URL}")
    DOWNLOADS_FILENAME_LIST+=("${PATCH_FILENAME}")
    DOWNLOADS_SIZE_LIST+=("${PATCH_DOWNLOAD_SIZE}")

    term::step::complete
  }
  step::read_patch_meta_from_github

  # shellcheck shell=bash

  step::download_files() {
    for i in "${!DOWNLOADS_URL_LIST[@]}"; do
      local DOWNLOAD_URL="${DOWNLOADS_URL_LIST[i]}"
      local DOWNLOAD_FILENAME="${DOWNLOADS_FILENAME_LIST[i]}"
      local DOWNLOAD_SIZE="${DOWNLOADS_SIZE_LIST[i]}"

      DOWNLOAD_PATH="${_arg_destination%/}/Installer/${DOWNLOAD_FILENAME}"

      if [ -f "${DOWNLOAD_PATH}" ] && [ -n "${DOWNLOAD_SIZE:-}" ]; then
        local EXISTING_FILESIZE
        EXISTING_FILESIZE=$(stat --format=%s "${DOWNLOAD_PATH}")

        if [ "${EXISTING_FILESIZE}" -eq "${DOWNLOAD_SIZE}" ]; then
          term::step::new "Download ${DOWNLOAD_FILENAME}"
          term::step::skipped "SKIPPED: File already exists"
          continue
        fi
      fi

      downloader::download_file "${DOWNLOAD_URL}" "${DOWNLOAD_PATH}"
    done
  }
  step::download_files

  # shellcheck shell=bash

  step::unarchive_generic() {
    local ITEM_NAME="${1:-}"
    local ARCHIVE_PATH="${2:-}"
    local TARGET_PATH="${3:-}"
    local IGNORE_PATTERNS_VAR_NAME="${4:-}"
    local IGNORE_PATTERNS_RECURSIVE_VAR_NAME="${5:-}"

    if [ -z "${ITEM_NAME}" ] || [ -z "${ARCHIVE_PATH}" ] || [ -z "${TARGET_PATH}" ]; then
      return 1
    fi

    if [ ! -d "${TARGET_PATH}" ]; then
      # Create the installation folder
      mkdir -p "${TARGET_PATH}" &>/dev/null || {
        term::step::failed_with_error "User does not have permission to create staging folder. Aborting installation."
        return 77 #E_PERM
      }
    fi

    unarchiver::unarchive_file "${ITEM_NAME}" "${ARCHIVE_PATH}" "${TARGET_PATH}" "${IGNORE_PATTERNS_VAR_NAME}" "${IGNORE_PATTERNS_RECURSIVE_VAR_NAME}"
  }
  step::unarchive_generic "Game Files" "${_arg_destination%/}/Installer/${DOWNLOADS_FILENAME_LIST[0]}" "${_arg_destination%/}" "UNPACK_IGNORE_PATTERNS"
  step::unarchive_generic "Bonus Pack 4" "${_arg_destination%/}/Installer/${DOWNLOADS_FILENAME_LIST[1]}" "${_arg_destination%/}"
  step::unarchive_generic "Latest Patch" "${_arg_destination%/}/Installer/${DOWNLOADS_FILENAME_LIST[2]}" "${_arg_destination%/}"

  # shellcheck shell=bash

  step::unpack_uz_maps() {
    term::step::new "Unpack Maps"

    exec 6<&0

    local KDIALOG_DBUS_ADDRESS=()

    if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
      read -ra KDIALOG_DBUS_ADDRESS < <(kdialog --title "${CURRENT_STEP_NAME}" --progressbar "Unpacking maps..." 0 2>/dev/null)
      busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "showCancelButton" b "false" 2>/dev/null || true
    fi

    __downloader::unpack_uz_maps::run | while IFS= read -r UNPACK_PROGRESS; do
      if [ -z "${UNPACK_PROGRESS}" ]; then
        term::step::progress "" >&6

        if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
          busctl --user set-property "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "maximum" i 0 2>/dev/null || true
        fi
        continue
      fi

      local TOTAL_FILES="${UNPACK_PROGRESS%%|*}"
      UNPACK_PROGRESS="${UNPACK_PROGRESS#*|}"

      local PERCENT="${UNPACK_PROGRESS%%|*}"
      UNPACK_PROGRESS="${UNPACK_PROGRESS#*|}"

      local CURRENT_FILE_INDEX="${UNPACK_PROGRESS%%|*}"
      UNPACK_PROGRESS="${UNPACK_PROGRESS#*|}"

      local MAP_NAME="${UNPACK_PROGRESS}"

      term::step::progress "${CURRENT_FILE_INDEX} of ${TOTAL_FILES} - ${MAP_NAME}" >&6

      local DIALOG_TEXT="Unpacking ${MAP_NAME} (${CURRENT_FILE_INDEX} of ${TOTAL_FILES})"

      if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
        local ESCAPED_DIALOG_TEXT
        ESCAPED_DIALOG_TEXT="$(echo -e "${DIALOG_TEXT}")"
        busctl --user set-property "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "maximum" i "${TOTAL_FILES}" 2>/dev/null || true
        busctl --user set-property "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "value" i "${CURRENT_FILE_INDEX}" 2>/dev/null || true
        busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "setLabelText" s "${ESCAPED_DIALOG_TEXT}" 2>/dev/null || true
      elif [ "${_arg_ui_mode:-none}" == "zenity" ]; then
        echo "${PERCENT}"
        echo "# ${DIALOG_TEXT}"
      fi
    done | {
      if [ "${_arg_ui_mode:-none}" == "zenity" ]; then
        zenity --progress --percentage=0 --text="Unpacking maps..." --no-cancel --time-remaining --auto-close 2>/dev/null
      else
        cat - >/dev/null
      fi
    } || {
      exec 0<&6 6<&-

      if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
        busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "close" 2>/dev/null || true
      fi

      term::step::failed_with_error "Failed to unpack all maps. Installation aborted."
      return 1
    }

    exec 0<&6 6<&-

    if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
      busctl --user call "${KDIALOG_DBUS_ADDRESS[@]}" "org.kde.kdialog.ProgressDialog" "close" 2>/dev/null || true
    fi

    term::step::complete
  }

  __downloader::unpack_uz_maps::run() {
    local LAST_UPDATE=""
    local CURRENT_UPDATE=""

    exec 3< <(__step::unpack_uz_maps::run::raw)
    local PROC_SUB_PID=$!

    trap '[ -n "${PROC_SUB_PID:-}" ] && { kill -- "${PROC_SUB_PID}"; }' EXIT

    local CAN_WRITE="y"
    trap 'CAN_WRITE="n"' SIGPIPE

    while kill -0 "${PROC_SUB_PID}" 2>/dev/null; do
      while IFS= read -r -u 3 -t 0.001 CURRENT_UPDATE; do
        LAST_UPDATE="${CURRENT_UPDATE}"
      done

      if [ "${CAN_WRITE}" == "y" ]; then
        echo "${LAST_UPDATE}" 2>/dev/null
        sleep "${DOWNLOADER_PROGRESS_MIN_REFRESH}"
      else
        break
      fi
    done

    trap - SIGPIPE EXIT

    local EXIT_CODE=1

    if [ "${CAN_WRITE}" == "y" ]; then
      # Final drain of remaining data
      while IFS= read -r -u 3 CURRENT_UPDATE; do
        LAST_UPDATE="${CURRENT_UPDATE}"
      done
      echo "${LAST_UPDATE}"
    else
      if kill -0 "${PROC_SUB_PID}" 2>/dev/null; then
        # Explicitly kill if the loop exited due to CAN_WRITE="n"
        kill -TERM -- "${PROC_SUB_PID}"
      fi

      return 1
    fi

    wait "${PROC_SUB_PID}"
    EXIT_CODE=$?

    exec 3<&-
    return "${EXIT_CODE}"
  }

  __step::unpack_uz_maps::run::raw() {
    local UCC_BIN_PATH="${_arg_destination%/}/System${UE_SYSTEM_FOLDER_SUFFIX:-}/ucc-bin-${ARCHITECTURE_SUFFIX}"

    local MAP_FILES=()
    local MAP_FILE

    for MAP_FILE in "${_arg_destination%/}/Maps"/*.unr.uz; do
      local MAP_BASENAME="${MAP_FILE##*/}"
      MAP_FILES+=("${MAP_BASENAME}")
    done

    local TOTAL_MAP_FILES="${#MAP_FILES[@]}"
    local MAP_FILES_PROCESSED=0

    for MAP_FILE in "${MAP_FILES[@]}"; do
      local MAP_BASENAME_UNCOMPRESSED="${MAP_FILE%.uz}"

      local COMPRESSED_FILE="${_arg_destination%/}/Maps/${MAP_FILE}"
      local DECOMPRESS_STAGING="${_arg_destination%/}/System${UE_SYSTEM_FOLDER_SUFFIX:-}/${MAP_BASENAME_UNCOMPRESSED}"
      local DECOMPRESS_TARGET="${_arg_destination%/}/Maps/${MAP_BASENAME_UNCOMPRESSED}"

      local PERCENT_PROGRESS="$(((MAP_FILES_PROCESSED * 100) / TOTAL_MAP_FILES))"
      MAP_FILES_PROCESSED=$((MAP_FILES_PROCESSED + 1))

      echo "${TOTAL_MAP_FILES}|${PERCENT_PROGRESS}|${MAP_FILES_PROCESSED}|${MAP_BASENAME_UNCOMPRESSED}"

      if [ -f "${DECOMPRESS_TARGET}" ]; then
        rm -f "${COMPRESSED_FILE}"
      else
        "${UCC_BIN_PATH}" decompress "../Maps/${MAP_FILE}" -nohomedir &>/dev/null || {
          return 1
        }

        if [ -f "${DECOMPRESS_STAGING}" ]; then
          { mv -f "${DECOMPRESS_STAGING}" "${DECOMPRESS_TARGET}" && rm -f "${COMPRESSED_FILE}"; } || {
            return 1
          }
        else
          return 1
        fi
      fi
    done
  }
  step::unpack_uz_maps

  # shellcheck shell=bash

  step::create_desktop_file() {
    if [ "${_arg_ui_mode:-none}" == "none" ]; then
      __step::create_desktop_file::text
      return $?
    fi

    term::step::new ".desktop File"

    local DIALOG_TEXT="Do you want to create an application menu entry?"
    local DIALOG_ARGS=()

    if [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
      DIALOG_ARGS=(
        kdialog
        --yesno
        "${DIALOG_TEXT}"
      )
    elif [ "${_arg_ui_mode:-none}" == "zenity" ]; then
      DIALOG_ARGS=(
        zenity
        --question
        "--text=${DIALOG_TEXT}"
      )
    fi

    if ! "${DIALOG_ARGS[@]}" &>/dev/null; then
      term::step::skipped "SKIPPED: User opted out"
      return 0
    fi

    __step::create_desktop_file::create_file
    term::step::complete
  }

  __step::create_desktop_file::text() {
    echo
    if ! term::yesno "Do you want to create an application menu entry?"; then
      echo
      term::step::new ".desktop File"
      term::step::skipped "SKIPPED: User opted out"
      return 0
    fi

    echo
    term::step::new ".desktop File"
    __step::create_desktop_file::create_file

    term::step::complete
  }

  __step::create_desktop_file::create_file() {
    local XDG_APPLICATIONS_FOLDER="${XDG_DATA_HOME:-${HOME}/.local/share}/applications"

    mkdir -p "${XDG_APPLICATIONS_FOLDER}" 2>/dev/null || {
      term::step::failed_with_error "User does not have permission to create folder."
      return 77 #E_PERM
    }

    DESKTOP_ENTRY="${XDG_APPLICATIONS_FOLDER}/OldUnreal-${PRODUCT_SHORTNAME}.desktop"

    {
      echo "[Desktop Entry]"
      echo "Name=${PRODUCT_NAME}"
      echo "Exec="'"'"${_arg_destination%/}/System${UE_SYSTEM_FOLDER_SUFFIX:-}/${MAIN_BINARY_NAME}-${ARCHITECTURE_SUFFIX}"'"'
      echo "Icon=${_arg_destination%/}/${PRODUCT_ICONPATH:-Help/Unreal.ico}"
      echo "Terminal=false"
      echo "Type=Application"
      echo "Categories=Game;"
    } >"${DESKTOP_ENTRY}" || {
      term::step::failed_with_error "User does not have permission to create .desktop file."
      return 77 #E_PERM
    }
  }
  step::create_desktop_file

  # shellcheck shell=bash

  step::notify_install_finished() {
    # Remove installation files
    if [ "${_arg_keep_installer_files:-off}" != "on" ] && [ -d "${_arg_destination%/}/Installer" ]; then
      rm -rf "${_arg_destination%/}/Installer"
    fi

    echo
    echo -e "$(ansi::styled "${PRODUCT_NAME}" "${ansi_stylenum[bright]}" "${ansi_colornum[green]}") $(ansi::styled "is now installed!" "" "${ansi_colornum[green]}")"
    echo
    echo "You can launch the game by running:"
    echo "  ${DESTINATION_HOMIFIED}/System${UE_SYSTEM_FOLDER_SUFFIX:-}/${MAIN_BINARY_NAME}-${ARCHITECTURE_SUFFIX}"

    local DIALOG_TEXT="""
${PRODUCT_NAME} is now installed!

You can launch the game by running:

  ${DESTINATION_HOMIFIED}/System${UE_SYSTEM_FOLDER_SUFFIX:-}/${MAIN_BINARY_NAME}-${ARCHITECTURE_SUFFIX}
"""

    if [ "${_arg_ui_mode:-none}" == "none" ]; then
      return 0
    elif [ "${_arg_ui_mode:-none}" == "kdialog" ]; then
      DIALOG_ARGS=(
        kdialog
        --msgbox
        "${DIALOG_TEXT}"
      )
    elif [ "${_arg_ui_mode:-none}" == "zenity" ]; then
      DIALOG_ARGS=(
        zenity
        --info
        --width=400
        "--text=${DIALOG_TEXT}"
      )
    fi

    "${DIALOG_ARGS[@]}" &>/dev/null || true
  }
  step::notify_install_finished
}

installer::entrypoint
# ] <-- needed because of Argbash
